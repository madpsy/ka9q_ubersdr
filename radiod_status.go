package main

import (
	"context"
	"encoding/binary"
	"fmt"
	"log"
	"math"
	"net"
	"sync"
	"syscall"
	"time"

	"golang.org/x/net/ipv4"
)

// Status tag numbers from ka9q-radio/src/status.h enum status_type
// Generated by generate_channel_status_tags.py to ensure correctness
const (
	// Common tags
	tagEOL         = 0
	tagCommandTag  = 1
	tagCmdCnt      = 2 // CMD_CNT
	tagGpsTime     = 3 // GPS_TIME
	tagSetopts     = 6 // SETOPTS
	tagClearopts   = 7 // CLEAROPTS
	tagRtpTimesnap = 8 // RTP_TIMESNAP

	// Frontend/Input tags
	tagInputSamprate    = 10  // INPUT_SAMPRATE
	tagLNAGain          = 25  // LNA_GAIN
	tagMixerGain        = 26  // MIXER_GAIN
	tagIFGain           = 27  // IF_GAIN
	tagIFPower          = 45  // IF_POWER
	tagRFAtten          = 97  // RF_ATTEN
	tagRFGain           = 98  // RF_GAIN
	tagRFAGC            = 99  // RF_AGC
	tagADOver           = 104 // AD_OVER - A/D overrange count
	tagSamplesSinceOver = 108 // SAMPLES_SINCE_OVER

	// Output/RTP tags
	tagOutputDataSourceSocket = 16  // OUTPUT_DATA_SOURCE_SOCKET
	tagOutputDataDestSocket   = 17  // OUTPUT_DATA_DEST_SOCKET
	tagOutputSSRC             = 18  // OUTPUT_SSRC
	tagOutputTtl              = 19  // OUTPUT_TTL
	tagOutputSamprate         = 20  // OUTPUT_SAMPRATE
	tagOutputMetadataPackets  = 21  // OUTPUT_METADATA_PACKETS
	tagOutputDataPackets      = 22  // OUTPUT_DATA_PACKETS
	tagOutputErrors           = 23  // OUTPUT_ERRORS
	tagOutputLevel            = 69  // OUTPUT_LEVEL
	tagOutputSamples          = 70  // OUTPUT_SAMPLES
	tagRtpPt                  = 105 // RTP_PT
	tagOutputEncoding         = 107 // OUTPUT_ENCODING

	// Tuning/Frequency tags
	tagRadioFrequency       = 33 // RADIO_FREQUENCY
	tagSecondLoFrequency    = 35 // SECOND_LO_FREQUENCY
	tagShiftFrequency       = 36 // SHIFT_FREQUENCY
	tagDopplerFrequency     = 37 // DOPPLER_FREQUENCY
	tagDopplerFrequencyRate = 38 // DOPPLER_FREQUENCY_RATE

	// Filter tags
	tagLowEdge           = 39  // LOW_EDGE
	tagHighEdge          = 40  // HIGH_EDGE
	tagKaiserBeta        = 41  // KAISER_BETA
	tagFilterBlocksize   = 42  // FILTER_BLOCKSIZE - L value
	tagFilterFirLength   = 43  // FILTER_FIR_LENGTH - M value
	tagFilter2           = 44  // FILTER2
	tagFilterDrops       = 77  // FILTER_DROPS
	tagFilter2Blocksize  = 73  // FILTER2_BLOCKSIZE
	tagFilter2FirLength  = 74  // FILTER2_FIR_LENGTH
	tagFilter2KaiserBeta = 75  // FILTER2_KAISER_BETA
	tagFeIsReal          = 102 // FE_ISREAL - real vs complex sampling

	// Signal quality tags
	tagBasebandPower = 46 // BASEBAND_POWER
	tagNoiseDensity  = 47 // NOISE_DENSITY
	tagPllSnr        = 58 // PLL_SNR
	tagFreqOffset    = 59 // FREQ_OFFSET
	tagFmSnr         = 66 // FM_SNR

	// Demodulator configuration tags
	tagDemodType           = 48  // DEMOD_TYPE
	tagOutputChannels      = 49  // OUTPUT_CHANNELS
	tagIndependentSideband = 50  // INDEPENDENT_SIDEBAND
	tagPllEnable           = 51  // PLL_ENABLE
	tagPllLock             = 52  // PLL_LOCK
	tagPllSquare           = 53  // PLL_SQUARE
	tagPllPhase            = 54  // PLL_PHASE
	tagPllBw               = 55  // PLL_BW
	tagEnvelope            = 56  // ENVELOPE
	tagSnrSquelch          = 57  // SNR_SQUELCH
	tagPllWraps            = 109 // PLL_WRAPS

	// FM-specific tags
	tagPeakDeviation = 60 // PEAK_DEVIATION
	tagPlTone        = 61 // PL_TONE
	tagDeemphTc      = 86 // DEEMPH_TC
	tagDeemphGain    = 87 // DEEMPH_GAIN
	tagPlDeviation   = 89 // PL_DEVIATION
	tagThreshExtend  = 90 // THRESH_EXTEND

	// AGC/Gain tags
	tagAgcEnable       = 62 // AGC_ENABLE
	tagHeadroom        = 63 // HEADROOM
	tagAgcHangtime     = 64 // AGC_HANGTIME
	tagAgcRecoveryRate = 65 // AGC_RECOVERY_RATE
	tagAgcThreshold    = 67 // AGC_THRESHOLD
	tagGain            = 68 // GAIN

	// Squelch tags
	tagSquelchOpen  = 83 // SQUELCH_OPEN
	tagSquelchClose = 84 // SQUELCH_CLOSE

	// Spectrum analysis tags
	tagCoherentBinSpacing = 92 // COHERENT_BIN_SPACING
	tagNoncoherentBinBw   = 93 // NONCOHERENT_BIN_BW
	tagBinCount           = 94 // BIN_COUNT
	tagBinData            = 96 // BIN_DATA

	// Codec/encoding tags
	tagOpusBitRate = 71 // OPUS_BIT_RATE
	tagMinpacket   = 72 // MINPACKET

	// Metadata/control tags
	tagLock            = 78  // LOCK
	tagPreset          = 85  // PRESET
	tagBlocksSincePoll = 103 // BLOCKS_SINCE_POLL
	tagStatusInterval  = 106 // STATUS_INTERVAL

	// Test points
	tagTp1 = 79 // TP1
	tagTp2 = 80 // TP2
)

// Packet type constants
const (
	pktTypeStatus = 0
	pktTypeCmd    = 1
)

// FrontendStatus holds frontend gain and overload information from radiod
type FrontendStatus struct {
	SSRC             uint32    // Channel SSRC this status belongs to
	InputSamprate    int       // Input sample rate in Hz
	LNAGain          int32     // LNA gain in dB
	MixerGain        int32     // Mixer gain in dB
	IFGain           int32     // IF gain in dB
	RFGain           float32   // RF gain (float)
	RFAtten          float32   // RF attenuation (float)
	RFAGC            int32     // RF AGC on/off
	IFPower          float32   // IF power in dBFS
	ADOverranges     int64     // A/D overrange count
	SamplesSinceOver int64     // Samples since last overrange
	FilterBlocksize  int       `json:"filter_blocksize"`  // L - input buffer length for FFT
	FilterFirLength  int       `json:"filter_fir_length"` // M - FIR impulse length for FFT
	FeIsReal         bool      `json:"fe_is_real"`        // Real vs complex sampling (true = real-to-complex FFT)
	LastUpdate       time.Time // When this status was last updated
}

// ChannelStatus holds per-channel audio status information from radiod
// This includes tuning, signal quality, demodulator settings, and output parameters
type ChannelStatus struct {
	SSRC       uint32    // Channel SSRC this status belongs to
	LastUpdate time.Time // When this status was last updated

	// Tuning/Frequency
	RadioFrequency       float64 // Main tuned frequency (Hz)
	SecondLoFrequency    float64 // Second LO frequency (Hz)
	ShiftFrequency       float64 // Frequency shift (Hz)
	DopplerFrequency     float64 // Doppler correction (Hz)
	DopplerFrequencyRate float64 // Doppler rate (Hz/s)
	FreqOffset           float32 // Frequency offset from center (Hz)

	// Filter settings
	LowEdge           float32 // Filter low edge (Hz)
	HighEdge          float32 // Filter high edge (Hz)
	KaiserBeta        float32 // Kaiser window beta
	FilterDrops       int     // Dropped filter blocks
	Filter2           int     // Second filter blocking factor
	Filter2Blocksize  int     // Second filter block size
	Filter2FirLength  int     // Second filter FIR length
	Filter2KaiserBeta float32 // Second filter Kaiser beta

	// Signal quality
	BasebandPower float32 // Baseband signal power (dBFS)
	NoiseDensity  float32 // Noise density N0 (dBFS)
	PllSnr        float32 // PLL SNR (dB)
	FmSnr         float32 // FM SNR (dB)

	// Demodulator configuration
	DemodType           int     // Demodulation type (0=linear, 1=FM, 2=WFM, 3=spectrum)
	OutputChannels      int     // Number of output channels (1=mono, 2=stereo)
	IndependentSideband bool    // ISB mode flag
	PllEnable           bool    // PLL enable
	PllLock             bool    // PLL lock status
	PllSquare           bool    // PLL squaring mode
	PllPhase            float32 // PLL carrier phase
	PllBw               float32 // PLL loop bandwidth (Hz)
	PllWraps            int64   // PLL phase rotations/wraps
	Envelope            bool    // Envelope detection mode
	SnrSquelch          bool    // SNR squelch enabled
	Lock                bool    // Tuner locked (ignores retune commands)

	// FM-specific
	PeakDeviation float32 // FM peak deviation (Hz)
	PlTone        float32 // PL tone frequency (Hz)
	PlDeviation   float32 // PL tone deviation (Hz)
	DeemphTc      float32 // De-emphasis time constant
	DeemphGain    float32 // De-emphasis gain
	ThreshExtend  bool    // Threshold extension enable

	// AGC/Gain
	AgcEnable       bool    // AGC enabled
	Headroom        float32 // AGC headroom (dB)
	AgcHangtime     float32 // AGC hang time (seconds)
	AgcRecoveryRate float32 // AGC recovery rate (dB/s)
	AgcThreshold    float32 // AGC threshold (dB)
	Gain            float32 // Output gain (dB)

	// Squelch
	SquelchOpen  float32 // Squelch open threshold (dB SNR)
	SquelchClose float32 // Squelch close threshold (dB SNR)

	// Output/RTP
	OutputSamprate        int     // Output sample rate (Hz)
	OutputLevel           float32 // Output power level (dB)
	OutputSamples         int64   // Total output samples
	OutputDataPackets     int64   // RTP data packets sent
	OutputMetadataPackets int64   // Status packets sent
	OutputErrors          int64   // Output error count
	RtpPt                 int     // RTP payload type
	OutputEncoding        int     // Output encoding format
	OpusBitRate           int     // Opus codec bitrate
	Minpacket             int     // Minimum packet size

	// Spectrum analysis
	CoherentBinSpacing float32 // Coherent bin spacing (Hz)
	NoncoherentBinBw   float32 // Noncoherent bin bandwidth (Hz)
	BinCount           int     // Number of spectrum bins

	// Metadata
	Preset          string // Channel preset name
	BlocksSincePoll int64  // Blocks since last poll
	StatusInterval  int    // Status update interval
	GpsTime         int64  // GPS timestamp (nanoseconds)
	CmdCnt          int32  // Command packet count

	// Test points
	Tp1 float32 // Test point 1
	Tp2 float32 // Test point 2
}

// FrontendStatusTracker manages frontend and channel status from radiod STATUS packets
type FrontendStatusTracker struct {
	mu             sync.RWMutex
	frontendStatus map[uint32]*FrontendStatus // Map of SSRC -> FrontendStatus
	channelStatus  map[uint32]*ChannelStatus  // Map of SSRC -> ChannelStatus
	statusListener *net.UDPConn
	stopListener   chan struct{}
	debugLogged    map[uint32]bool            // Track which SSRCs we've logged debug info for
}

// NewFrontendStatusTracker creates a new frontend status tracker
func NewFrontendStatusTracker() *FrontendStatusTracker {
	fst := &FrontendStatusTracker{
		frontendStatus: make(map[uint32]*FrontendStatus),
		channelStatus:  make(map[uint32]*ChannelStatus),
		stopListener:   make(chan struct{}),
		debugLogged:    make(map[uint32]bool),
	}

	// Start cleanup goroutine to remove stale entries
	go fst.cleanupStaleEntries()

	return fst
}

// cleanupStaleEntries removes status entries that haven't been updated in 30 seconds
// This prevents terminated channels from lingering in the cache
func (fst *FrontendStatusTracker) cleanupStaleEntries() {
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-fst.stopListener:
			return
		case <-ticker.C:
			now := time.Now()
			staleThreshold := 30 * time.Second

			fst.mu.Lock()

			// Clean up stale frontend status entries
			for ssrc, status := range fst.frontendStatus {
				if now.Sub(status.LastUpdate) > staleThreshold {
					delete(fst.frontendStatus, ssrc)
					log.Printf("Removed stale frontend status for SSRC 0x%08x (last update: %v ago)",
						ssrc, now.Sub(status.LastUpdate))
				}
			}

			// Clean up stale channel status entries
			for ssrc, status := range fst.channelStatus {
				if now.Sub(status.LastUpdate) > staleThreshold {
					delete(fst.channelStatus, ssrc)
					log.Printf("Removed stale channel status for SSRC 0x%08x (last update: %v ago)",
						ssrc, now.Sub(status.LastUpdate))
				}
			}

			fst.mu.Unlock()
		}
	}
}

// StartStatusListener starts listening for STATUS packets from radiod
func (fst *FrontendStatusTracker) StartStatusListener(statusAddr *net.UDPAddr, iface *net.Interface) error {
	// Create UDP socket with SO_REUSEADDR and SO_REUSEPORT to allow multiple listeners
	lc := net.ListenConfig{
		Control: func(network, address string, c syscall.RawConn) error {
			var opErr error
			if err := c.Control(func(fd uintptr) {
				// Set SO_REUSEADDR to allow multiple binds to same address
				if err := syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1); err != nil {
					opErr = fmt.Errorf("failed to set SO_REUSEADDR: %w", err)
					return
				}
				// Set SO_REUSEPORT to allow multiple processes/goroutines to bind to same port
				if err := syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, SO_REUSEPORT, 1); err != nil {
					opErr = fmt.Errorf("failed to set SO_REUSEPORT: %w", err)
					return
				}
			}); err != nil {
				return err
			}
			return opErr
		},
	}

	// Listen on the multicast address with reuse options
	listenPacket, err := lc.ListenPacket(context.Background(), "udp4", statusAddr.String())
	if err != nil {
		return fmt.Errorf("failed to create STATUS listener: %w", err)
	}

	conn := listenPacket.(*net.UDPConn)

	// Join multicast group
	p := ipv4.NewPacketConn(conn)
	if iface != nil {
		if err := p.JoinGroup(iface, statusAddr); err != nil {
			conn.Close()
			return fmt.Errorf("failed to join STATUS multicast group: %w", err)
		}
	}

	// Also join on loopback for local traffic
	loopback, err := getLoopbackInterface()
	if err == nil && loopback != nil {
		if err := p.JoinGroup(loopback, statusAddr); err != nil {
			log.Printf("Warning: failed to join STATUS multicast group on loopback: %v", err)
		}
	}

	fst.statusListener = conn
	log.Printf("Started frontend STATUS packet listener on %s (with SO_REUSEPORT)", statusAddr)

	// Start listener goroutine
	go fst.listenLoop()

	return nil
}

// listenLoop continuously receives and processes STATUS packets
func (fst *FrontendStatusTracker) listenLoop() {
	buf := make([]byte, 9000) // Large enough for any STATUS packet

	for {
		select {
		case <-fst.stopListener:
			return
		default:
		}

		// Set read deadline to allow checking stop channel
		fst.statusListener.SetReadDeadline(time.Now().Add(1 * time.Second))

		n, _, err := fst.statusListener.ReadFromUDP(buf)
		if err != nil {
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				continue // Timeout is expected, check stop channel
			}
			log.Printf("Error reading STATUS packet: %v", err)
			continue
		}

		if n < 2 {
			continue // Too short
		}

		// Check packet type (first byte)
		if buf[0] != pktTypeStatus {
			continue // Not a STATUS packet
		}

		// Parse STATUS packet
		fst.parseStatusPacket(buf[1:n])
	}
}

// parseStatusPacket parses a STATUS packet and extracts frontend and channel parameters
func (fst *FrontendStatusTracker) parseStatusPacket(data []byte) {
	frontendStatus := &FrontendStatus{
		LastUpdate: time.Now(),
	}
	channelStatus := &ChannelStatus{
		LastUpdate: time.Now(),
	}

	offset := 0
	for offset < len(data) {
		if offset+1 >= len(data) {
			break
		}

		tag := data[offset]
		offset++

		// EOL marker
		if tag == tagEOL {
			break
		}

		// Read length
		length := int(data[offset])
		offset++

		// Handle extended length encoding (length >= 128)
		if length&0x80 != 0 {
			lengthOfLength := length & 0x7f
			length = 0
			for i := 0; i < lengthOfLength && offset < len(data); i++ {
				length = (length << 8) | int(data[offset])
				offset++
			}
		}

		// Check bounds
		if offset+length > len(data) {
			break
		}

		// Extract value based on tag
		value := data[offset : offset+length]
		switch tag {
		// Common tags
		case tagOutputSSRC:
			ssrc := decodeInt32(value)
			frontendStatus.SSRC = ssrc
			channelStatus.SSRC = ssrc
		case tagCmdCnt:
			channelStatus.CmdCnt = int32(decodeInt(value))
		case tagGpsTime:
			channelStatus.GpsTime = decodeInt64(value)

		// Frontend tags
		case tagInputSamprate:
			frontendStatus.InputSamprate = decodeInt(value)
		case tagLNAGain:
			frontendStatus.LNAGain = int32(decodeInt8(value))
		case tagMixerGain:
			frontendStatus.MixerGain = int32(decodeInt8(value))
		case tagIFGain:
			frontendStatus.IFGain = int32(decodeInt8(value))
		case tagRFGain:
			frontendStatus.RFGain = decodeFloat(value)
		case tagRFAtten:
			frontendStatus.RFAtten = decodeFloat(value)
		case tagRFAGC:
			frontendStatus.RFAGC = int32(decodeInt(value))
		case tagIFPower:
			frontendStatus.IFPower = decodeFloat(value)
		case tagADOver:
			frontendStatus.ADOverranges = decodeInt64(value)
		case tagSamplesSinceOver:
			frontendStatus.SamplesSinceOver = decodeInt64(value)
		case tagFilterBlocksize:
			frontendStatus.FilterBlocksize = int(decodeInt32(value))
		case tagFilterFirLength:
			frontendStatus.FilterFirLength = int(decodeInt32(value))
		case tagFeIsReal:
			frontendStatus.FeIsReal = decodeBool(value)

		// Tuning/Frequency tags
		case tagRadioFrequency:
			channelStatus.RadioFrequency = decodeDouble(value)
		case tagSecondLoFrequency:
			channelStatus.SecondLoFrequency = decodeDouble(value)
		case tagShiftFrequency:
			channelStatus.ShiftFrequency = decodeDouble(value)
		case tagDopplerFrequency:
			channelStatus.DopplerFrequency = decodeDouble(value)
		case tagDopplerFrequencyRate:
			channelStatus.DopplerFrequencyRate = decodeDouble(value)
		case tagFreqOffset:
			channelStatus.FreqOffset = decodeFloat(value)

		// Filter tags
		case tagLowEdge:
			channelStatus.LowEdge = decodeFloat(value)
		case tagHighEdge:
			channelStatus.HighEdge = decodeFloat(value)
		case tagKaiserBeta:
			channelStatus.KaiserBeta = decodeFloat(value)
		case tagFilterDrops:
			channelStatus.FilterDrops = decodeInt(value)
		case tagFilter2:
			channelStatus.Filter2 = decodeInt(value)
		case tagFilter2Blocksize:
			channelStatus.Filter2Blocksize = decodeInt(value)
		case tagFilter2FirLength:
			channelStatus.Filter2FirLength = decodeInt(value)
		case tagFilter2KaiserBeta:
			channelStatus.Filter2KaiserBeta = decodeFloat(value)

		// Signal quality tags
		case tagBasebandPower:
			channelStatus.BasebandPower = decodeFloat(value)
		case tagNoiseDensity:
			channelStatus.NoiseDensity = decodeFloat(value)
		case tagPllSnr:
			channelStatus.PllSnr = decodeFloat(value)
		case tagFmSnr:
			channelStatus.FmSnr = decodeFloat(value)

		// Demodulator configuration tags
		case tagDemodType:
			channelStatus.DemodType = decodeInt(value)
		case tagOutputChannels:
			channelStatus.OutputChannels = decodeInt(value)
		case tagIndependentSideband:
			channelStatus.IndependentSideband = decodeBool(value)
		case tagPllEnable:
			channelStatus.PllEnable = decodeBool(value)
		case tagPllLock:
			channelStatus.PllLock = decodeBool(value)
		case tagPllSquare:
			channelStatus.PllSquare = decodeBool(value)
		case tagPllPhase:
			channelStatus.PllPhase = decodeFloat(value)
		case tagPllBw:
			channelStatus.PllBw = decodeFloat(value)
		case tagPllWraps:
			channelStatus.PllWraps = decodeInt64(value)
		case tagEnvelope:
			channelStatus.Envelope = decodeBool(value)
		case tagSnrSquelch:
			channelStatus.SnrSquelch = decodeBool(value)
		case tagLock:
			channelStatus.Lock = decodeBool(value)

		// FM-specific tags
		case tagPeakDeviation:
			channelStatus.PeakDeviation = decodeFloat(value)
		case tagPlTone:
			channelStatus.PlTone = decodeFloat(value)
		case tagPlDeviation:
			channelStatus.PlDeviation = decodeFloat(value)
		case tagDeemphTc:
			channelStatus.DeemphTc = decodeFloat(value)
		case tagDeemphGain:
			channelStatus.DeemphGain = decodeFloat(value)
		case tagThreshExtend:
			channelStatus.ThreshExtend = decodeBool(value)

		// AGC/Gain tags
		case tagAgcEnable:
			channelStatus.AgcEnable = decodeBool(value)
		case tagHeadroom:
			channelStatus.Headroom = decodeFloat(value)
		case tagAgcHangtime:
			channelStatus.AgcHangtime = decodeFloat(value)
		case tagAgcRecoveryRate:
			channelStatus.AgcRecoveryRate = decodeFloat(value)
		case tagAgcThreshold:
			channelStatus.AgcThreshold = decodeFloat(value)
		case tagGain:
			channelStatus.Gain = decodeFloat(value)

		// Squelch tags
		case tagSquelchOpen:
			channelStatus.SquelchOpen = decodeFloat(value)
		case tagSquelchClose:
			channelStatus.SquelchClose = decodeFloat(value)

		// Output/RTP tags
		case tagOutputSamprate:
			channelStatus.OutputSamprate = decodeInt(value)
		case tagOutputLevel:
			channelStatus.OutputLevel = decodeFloat(value)
		case tagOutputSamples:
			channelStatus.OutputSamples = decodeInt64(value)
		case tagOutputDataPackets:
			channelStatus.OutputDataPackets = decodeInt64(value)
		case tagOutputMetadataPackets:
			channelStatus.OutputMetadataPackets = decodeInt64(value)
		case tagOutputErrors:
			channelStatus.OutputErrors = decodeInt64(value)
		case tagRtpPt:
			channelStatus.RtpPt = decodeInt(value)
		case tagOutputEncoding:
			channelStatus.OutputEncoding = decodeInt(value)
		case tagOpusBitRate:
			channelStatus.OpusBitRate = decodeInt(value)
		case tagMinpacket:
			channelStatus.Minpacket = decodeInt(value)

		// Spectrum analysis tags
		case tagCoherentBinSpacing:
			channelStatus.CoherentBinSpacing = decodeFloat(value)
		case tagNoncoherentBinBw:
			channelStatus.NoncoherentBinBw = decodeFloat(value)
		case tagBinCount:
			channelStatus.BinCount = decodeInt(value)

		// Metadata tags
		case tagPreset:
			channelStatus.Preset = decodeString(value)
		case tagBlocksSincePoll:
			channelStatus.BlocksSincePoll = decodeInt64(value)
		case tagStatusInterval:
			channelStatus.StatusInterval = decodeInt(value)

		// Test points
		case tagTp1:
			channelStatus.Tp1 = decodeFloat(value)
		case tagTp2:
			channelStatus.Tp2 = decodeFloat(value)
		}

		offset += length
	}

	// Store status if we got an SSRC
	if frontendStatus.SSRC != 0 {
		// Debug log once per SSRC when we first see FFT fields
		if !fst.debugLogged[frontendStatus.SSRC] && (frontendStatus.FilterBlocksize > 0 || frontendStatus.FilterFirLength > 0) {
			log.Printf("DEBUG: First FFT data for SSRC 0x%08x: FilterBlocksize=%d, FilterFirLength=%d, FeIsReal=%v, InputSamprate=%d",
				frontendStatus.SSRC, frontendStatus.FilterBlocksize, frontendStatus.FilterFirLength, frontendStatus.FeIsReal, frontendStatus.InputSamprate)
			fst.debugLogged[frontendStatus.SSRC] = true
		}
		
		fst.mu.Lock()
		fst.frontendStatus[frontendStatus.SSRC] = frontendStatus
		fst.channelStatus[channelStatus.SSRC] = channelStatus
		fst.mu.Unlock()
	}
}

// GetFrontendStatus returns the frontend status for a given SSRC
func (fst *FrontendStatusTracker) GetFrontendStatus(ssrc uint32) *FrontendStatus {
	fst.mu.RLock()
	defer fst.mu.RUnlock()

	status, ok := fst.frontendStatus[ssrc]
	if !ok {
		return nil
	}

	// Return a copy to avoid race conditions
	statusCopy := *status
	return &statusCopy
}

// GetAllFrontendStatus returns all frontend status entries
func (fst *FrontendStatusTracker) GetAllFrontendStatus() map[uint32]*FrontendStatus {
	fst.mu.RLock()
	defer fst.mu.RUnlock()

	// Return a copy of the map
	result := make(map[uint32]*FrontendStatus, len(fst.frontendStatus))
	for ssrc, status := range fst.frontendStatus {
		statusCopy := *status
		result[ssrc] = &statusCopy
	}
	return result
}

// GetChannelStatus returns the channel status for a given SSRC
func (fst *FrontendStatusTracker) GetChannelStatus(ssrc uint32) *ChannelStatus {
	fst.mu.RLock()
	defer fst.mu.RUnlock()

	status, ok := fst.channelStatus[ssrc]
	if !ok {
		return nil
	}

	// Return a copy to avoid race conditions
	statusCopy := *status
	return &statusCopy
}

// GetAllChannelStatus returns all channel status entries
func (fst *FrontendStatusTracker) GetAllChannelStatus() map[uint32]*ChannelStatus {
	fst.mu.RLock()
	defer fst.mu.RUnlock()

	// Return a copy of the map
	result := make(map[uint32]*ChannelStatus, len(fst.channelStatus))
	for ssrc, status := range fst.channelStatus {
		statusCopy := *status
		result[ssrc] = &statusCopy
	}
	return result
}

// Stop stops the STATUS packet listener
func (fst *FrontendStatusTracker) Stop() {
	close(fst.stopListener)
	if fst.statusListener != nil {
		fst.statusListener.Close()
	}
}

// TLV Decoding functions - reverse of encoding functions in radiod.go

// decodeInt64 decodes a 64-bit integer with leading zero suppression
// Matches decode_int64 in ka9q-radio/src/status.c lines 218-226
func decodeInt64(data []byte) int64 {
	var result uint64
	for _, b := range data {
		result = (result << 8) | uint64(b)
	}
	return int64(result)
}

// decodeInt32 decodes a 32-bit integer with leading zero suppression
// Matches decode_int32 in ka9q-radio/src/status.c lines 227-229
func decodeInt32(data []byte) uint32 {
	return uint32(decodeInt64(data))
}

// decodeInt decodes a variable-length integer (like decode_int in ka9q-radio)
// Matches decode_int in ka9q-radio/src/status.c lines 241-243
// Returns int (native int size)
func decodeInt(data []byte) int {
	return int(decodeInt64(data))
}

// decodeFloat decodes a float32 with leading zero suppression
// Matches decode_float in ka9q-radio/src/status.c lines 246-256
func decodeFloat(data []byte) float32 {
	if len(data) == 0 {
		return 0
	}

	// Special case: if 8 bytes, decode as double and cast to float
	if len(data) == 8 {
		return float32(decodeDouble(data))
	}

	// Decode as uint64 (accumulates into low-order bits)
	// then reinterpret the low 32 bits as float32
	var bits uint64
	for _, b := range data {
		bits = (bits << 8) | uint64(b)
	}

	return math.Float32frombits(uint32(bits))
}

// decodeDouble decodes a float64 with leading zero suppression
// Matches decode_double in ka9q-radio/src/status.c lines 258-268
func decodeDouble(data []byte) float64 {
	if len(data) == 0 {
		return 0
	}

	// Special case: if 4 bytes, decode as float and cast to double
	if len(data) == 4 {
		return float64(decodeFloat(data))
	}

	// Decode as uint64 (accumulates into low-order bits)
	// then reinterpret as float64
	var bits uint64
	for _, b := range data {
		bits = (bits << 8) | uint64(b)
	}

	return math.Float64frombits(bits)
}

// decodeInt8 decodes an 8-bit integer
// Matches decode_int8 in ka9q-radio/src/status.c lines 234-236
func decodeInt8(data []byte) int8 {
	return int8(decodeInt64(data))
}

// decodeBool decodes a boolean value
// Matches decode_bool in ka9q-radio/src/status.c lines 237-239
func decodeBool(data []byte) bool {
	return decodeInt64(data) != 0
}

// decodeString decodes a string
func decodeString(data []byte) string {
	return string(data)
}

// Helper function to convert bytes to uint32 (big-endian)
func bytesToUint32(data []byte) uint32 {
	if len(data) < 4 {
		return 0
	}
	return binary.BigEndian.Uint32(data)
}

// Helper function to convert bytes to uint64 (big-endian)
func bytesToUint64(data []byte) uint64 {
	if len(data) < 8 {
		return 0
	}
	return binary.BigEndian.Uint64(data)
}
